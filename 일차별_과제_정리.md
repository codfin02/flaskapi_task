# FastAPI 과제 일차별 정리

## **1일차: FastAPI 기본 구조 및 API 작성**

### **완성된 내용**
**프로젝트 구조 설정**
```
fastapi_assignment/
│── app/
│   ├── models/          # 사용자 및 영화 모델
│   ├── schemas/         # Pydantic 스키마
│   ├── tests/           # 테스트 코드
│   └── __init__.py
├── main.py              # FastAPI 앱
├── pyproject.toml       # Poetry 설정
└── README.md            # 프로젝트 설명
```

**Pydantic 스키마 정의**
```python
class UserCreateRequest(BaseModel):
    username: str
    age: int
    gender: GenderEnum

class UserUpdateRequest(BaseModel):
    username: Optional[str] = None
    age: Optional[int] = None

class UserResponse(BaseModel):
    id: int
    username: str
    age: int
    gender: GenderEnum

class UserSearchParams(BaseModel):
    model_config = {"extra": "forbid"}
    username: Optional[Annotated[int, conint(gt=0)]] = None
    gender: Optional[GenderEnum] = None
```

**사용자 모델 구현**
```python
class UserModel:
    _data: ClassVar[List["UserModel"]] = []
    _id_counter: ClassVar[int] = 1
    
    @classmethod
    def create(cls, username: str, age: int, gender: str) -> "UserModel":
        return cls(username, age, gender)
```

**API 엔드포인트 구현**
- POST `/users` - 사용자 생성
- GET `/users` - 모든 사용자 조회
- GET `/users/{user_id}` - 특정 사용자 조회
- PATCH `/users/{user_id}` - 사용자 정보 수정
- DELETE `/users/{user_id}` - 사용자 삭제
- GET `/users/search` - 사용자 검색

**TDD 방식 테스트 코드**
- 11개 테스트 모두 통과
- 코드 커버리지 99% 달성
- 각 API 엔드포인트별 테스트 케이스

**코드 품질 관리 도구**
- Black (코드 포맷팅)
- Ruff (린팅)
- MyPy (타입 검증)
- Coverage (테스트 커버리지)

**통합 실행 스크립트**
```bash
./test.sh  # 모든 도구를 순차적으로 실행
```

### **학습 자료**
- [FastAPI 공식 튜토리얼](https://fastapi.tiangolo.com/tutorial/)
- [Pydantic 공식 문서](https://docs.pydantic.dev/)
- [FastAPI Path Parameters](https://fastapi.tiangolo.com/tutorial/path-params/)
- [FastAPI Query Parameters](https://fastapi.tiangolo.com/tutorial/query-params/)

---

## **2일차: 영화 관리 API 구현**

### **완성된 내용**
**영화 모델 구현**
```python
class MovieModel:
    _data: ClassVar[List["MovieModel"]] = []
    _id_counter: ClassVar[int] = 1

    def __init__(self, title: str, playtime: int, genre: List[str]) -> None:
        self.id = MovieModel._id_counter
        self.title: str = title
        self.playtime: int = playtime
        self.genre: List[str] = genre
        MovieModel._data.append(self)
        MovieModel._id_counter += 1

    @classmethod
    def create(cls, title: str, playtime: int, genre: List[str]) -> "MovieModel":
        return cls(title, playtime, genre)

    @classmethod
    def filter(cls, **kwargs: Union[str, int]) -> List["MovieModel"]:
        result = [
            movie for movie in cls._data
            if all(getattr(movie, key) == value or value in getattr(movie, key) 
                   for key, value in kwargs.items())
        ]
        return result
```

**영화 스키마 정의**
```python
class CreateMovieRequest(BaseModel):
    title: str
    playtime: int
    genre: List[str]

class MovieUpdateRequest(BaseModel):
    title: Optional[str] = None
    playtime: Optional[Annotated[int, Field(gt=0)]] = None
    genre: Optional[List[str]] = None

class MovieResponse(BaseModel):
    id: int
    title: str
    playtime: int
    genre: List[str]

class MovieSearchParams(BaseModel):
    title: Optional[str] = None
    genre: Optional[str] = None
```

**영화 API 엔드포인트**
- POST `/movies` - 영화 등록 (201 상태코드)
- GET `/movies` - 전체 영화 조회 및 검색 (200 상태코드)
- GET `/movies/{movie_id}` - 특정 영화 조회 (200 상태코드)
- PATCH `/movies/{movie_id}` - 영화 정보 수정 (200 상태코드)
- DELETE `/movies/{movie_id}` - 영화 삭제 (204 상태코드)

**고급 기능 구현**
- **Field(gt=0)**를 사용한 playtime 검증
- **상태 코드** 적절히 활용 (201, 200, 204)
- **쿼리 매개변수** 검색 기능 (제목, 장르)
- **타입 안전성** 완벽하게 구현

**테스트 코드**
- 10개 영화 API 테스트 모두 통과
- 전체 테스트 21개 통과
- **테스트 커버리지 100%** 달성

### **주요 특징**
- **Pydantic 모델**을 활용한 데이터 검증
- **타입 힌트** 완벽하게 적용
- **TDD 방식**으로 개발 진행
- **코드 품질** 검사 통과 (black, ruff, mypy)

---

## **3일차: 고급 FastAPI 기능 구현**

### **완성된 내용**
**프로젝트 구조 확장**
```
fastapi_assignment/
│── app/
│   ├── services/        # JWT, Auth 서비스
│   ├── middleware/      # 인증 미들웨어
│   ├── routers/         # API 라우터 분리
│   └── ...              # 기존 구조 유지
```

**비밀번호 보안 및 인증 시스템**
```python
from passlib.context import CryptContext

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

class UserModel:
    @staticmethod
    def get_hashed_password(password: str) -> str:
        return pwd_context.hash(password)

    @staticmethod
    def verify_password(plain_password: str, hashed_password: str) -> bool:
        return pwd_context.verify(plain_password, hashed_password)

    @classmethod
    def authenticate(cls, username: str, password: str) -> Optional["UserModel"]:
        for user in cls._data:
            if user.username == username and cls.verify_password(password, user.password):
                return user
        return None
```

**JWT 서비스 구현**
```python
class JWTService:
    def __init__(self) -> None:
        self.algorithm = "HS256"
        self.access_token_expires_in = 300      # 5분
        self.refresh_token_expires_in = 3600 * 24  # 24시간

    def create_access_token(self, data: dict[str, Any]) -> str:
        return self._create_token(data, self.access_token_expires_in)

    def create_refresh_token(self, data: dict[str, Any]) -> str:
        return self._create_token(data, self.refresh_token_expires_in)
```

**인증 서비스 및 미들웨어**
```python
class AuthService:
    def login(self, username: str, password: str) -> Response:
        user = UserModel.authenticate(username, password)
        if user is None:
            raise HTTPException(status_code=401, detail="Incorrect username or password")
        
        access_token = self.jwt_service.create_access_token(data={"user_id": user.id})
        refresh_token = self.jwt_service.create_refresh_token(data={"user_id": user.id})
        return self._get_login_response(access_token, refresh_token)

class AuthMiddleware(BaseHTTPMiddleware):
    async def dispatch(self, request: Request, call_next: RequestResponseEndpoint) -> Response:
        if request.url.path.startswith("/users"):
            if request.url.path not in ["/users/login", "/users", "/users/search"]:
                request = await AuthService().get_current_user(request)
        return await call_next(request)
```

**새로운 API 엔드포인트**
- POST `/users/login` - 사용자 로그인 및 JWT 토큰 발급 (204 상태코드)
- GET `/users/me` - 현재 사용자 정보 조회 (인증 필요)
- PATCH `/users/me` - 현재 사용자 정보 수정 (인증 필요)
- DELETE `/users/me` - 현재 사용자 삭제 (인증 필요)

**의존성 및 보안 기능**
- **passlib[bcrypt]**를 사용한 비밀번호 해싱
- **PyJWT**를 사용한 JWT 토큰 생성/검증
- **쿠키 기반** JWT 토큰 저장
- **미들웨어**를 통한 자동 인증 처리
- **의존성 주입**을 통한 서비스 관리

**업데이트된 스키마**
```python
class UserCreateRequest(BaseModel):
    username: str
    password: str  # 비밀번호 필드 추가
    age: int
    gender: GenderEnum

class UserLoginRequest(BaseModel):
    username: str
    password: str
```

### **주요 특징**
- **보안 강화**: bcrypt 해싱, JWT 토큰 기반 인증
- **아키텍처 개선**: 서비스 레이어, 미들웨어, 라우터 분리
- **의존성 관리**: Poetry를 통한 라이브러리 관리
- **타입 안전성**: 완벽한 타입 힌트 및 MyPy 검증
- **코드 구조화**: 모듈화된 구조로 유지보수성 향상 