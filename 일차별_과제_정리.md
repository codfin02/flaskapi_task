# FastAPI 과제 일차별 정리

## 1일차: FastAPI 기본 구조 및 API 작성

### 목표
- Poetry를 사용한 가상환경 구축 및 의존성 관리
- FastAPI 프로젝트 구성 및 서버 실행
- Pydantic 모델을 활용한 데이터 검증
- 경로 매개변수와 쿼리 매개변수 활용
- 코드 품질 관리 도구 설정 (ruff, black, mypy)
- pytest를 활용한 TDD 개발

### 프로젝트 구조
```
fastapi_assignment/
├── app/
│   ├── models/
│   │   ├── __init__.py
│   │   └── users.py          # 사용자 모델
│   ├── schemas/
│   │   ├── __init__.py
│   │   └── users.py          # Pydantic 스키마
│   ├── tests/
│   │   ├── __init__.py
│   │   └── test_user_router.py
│   └── __init__.py
├── main.py                   # FastAPI 애플리케이션
├── pyproject.toml           # Poetry 설정
├── conftest.py              # pytest 설정
├── test.sh                  # 통합 테스트 스크립트
└── README.md
```

### 구현된 기능

**사용자 관리 API**
- `POST /users` - 사용자 생성
- `GET /users` - 모든 사용자 조회
- `GET /users/{user_id}` - 특정 사용자 조회 (Path Parameter 검증)
- `PATCH /users/{user_id}` - 사용자 정보 부분 수정
- `DELETE /users/{user_id}` - 사용자 삭제
- `GET /users/search` - 사용자 검색 (Query Parameter 검증)

**Pydantic 스키마**
```python
class GenderEnum(str, Enum):
    MALE = "male"
    FEMALE = "female"

class UserCreateRequest(BaseModel):
    username: str
    age: int
    gender: GenderEnum

class UserUpdateRequest(BaseModel):
    username: Optional[str] = None
    age: Optional[int] = None

class UserSearchParams(BaseModel):
    model_config = {"extra": "forbid"}
    username: Optional[str] = None
    age: Optional[conint(gt=0)] = None
    gender: Optional[GenderEnum] = None
```

**코드 품질 도구**
- Black: 코드 포맷팅
- Ruff: 린팅 및 import 정리
- MyPy: 정적 타입 검사
- Coverage: 테스트 커버리지 측정

**테스트 결과**
- 전체 테스트: 16개 모두 통과
- 테스트 커버리지: 99% 달성

---

## 2일차: 영화 관리 API 구현

### 목표
- 다중 매개변수를 활용한 API 구성
- Pydantic Field를 이용한 모델 내 데이터 검증
- 중첩 모델 및 서브 모델 활용
- HTTP 상태 코드 적절한 활용
- 응답 모델(Response Model) 활용

### 추가된 구조
```
app/
├── models/
│   └── movies.py            # 영화 모델
└── schemas/
    └── movies.py            # 영화 Pydantic 스키마
```

### 구현된 기능

**영화 관리 API**
- `POST /movies` - 영화 등록 (201 Created)
- `GET /movies` - 전체 영화 조회 및 검색 (200 OK)
- `GET /movies/{movie_id}` - 특정 영화 상세 조회 (200 OK)
- `PATCH /movies/{movie_id}` - 영화 정보 수정 (200 OK)
- `DELETE /movies/{movie_id}` - 영화 삭제 (204 No Content)

**영화 스키마**
```python
class CreateMovieRequest(BaseModel):
    title: str
    playtime: int
    genre: list[str]

class MovieUpdateRequest(BaseModel):
    title: Optional[str] = None
    playtime: Optional[Annotated[int, Field(gt=0)]] = None
    genre: Optional[list[str]] = None

class MovieSearchParams(BaseModel):
    title: Optional[str] = None
    genre: Optional[str] = None
```

**주요 특징**
- Field(gt=0)를 사용한 playtime 검증
- 상태 코드별 적절한 응답 처리
- 장르 기반 검색 기능 구현
- Response Model을 활용한 일관된 응답 형식

**테스트 결과**
- 사용자 테스트: 16개 통과
- 영화 테스트: 9개 통과
- 전체 테스트: 25개 모두 통과

---

## 3일차: 고급 FastAPI 기능 구현

### 목표
- Shell Script 작성 및 활용
- GitHub Actions CI/CD 파이프라인 구축
- FastAPI 내부 모듈 및 함수 활용
- API 라우터 모듈화

### 확장된 구조
```
fastapi_assignment/
├── app/
│   ├── middleware/
│   │   ├── __init__.py
│   │   └── auth.py          # 인증 미들웨어
│   ├── routers/
│   │   ├── __init__.py
│   │   ├── users.py         # 사용자 라우터
│   │   └── movies.py        # 영화 라우터
│   └── services/
│       ├── __init__.py
│       ├── auth.py          # 인증 서비스
│       └── jwt.py           # JWT 서비스
├── .github/workflows/
│   └── ci.yml               # GitHub Actions 설정
└── test.sh                  # 개선된 테스트 스크립트
```

### 구현된 기능

**모듈화된 라우터**
- APIRouter를 사용한 엔드포인트 분리
- 태그별 API 그룹화
- 메인 앱에서 include_router()로 통합

**인증 시스템**
- JWT 기반 액세스/리프레시 토큰
- 비밀번호 bcrypt 해싱
- 쿠키 기반 토큰 전송
- 인증 미들웨어 자동 처리

**새로운 API 엔드포인트**
- `POST /users/login` - 사용자 로그인
- `GET /users/me` - 현재 사용자 정보 조회
- `PATCH /users/me` - 현재 사용자 정보 수정
- `DELETE /users/me` - 현재 사용자 삭제

**Shell Script 개선**
```bash
# 옵션 지원
./test.sh --skip-format    # 포맷팅 건너뛰기
./test.sh --skip-lint      # 린팅 건너뛰기
./test.sh --skip-type      # 타입 검사 건너뛰기
./test.sh --skip-test      # 테스트 건너뛰기
```

**GitHub Actions CI/CD**
- 정적 분석과 테스트 병렬 실행
- Poetry 캐싱으로 빌드 시간 단축
- MySQL 데이터베이스 자동 설정

---

## 4일차: 데이터베이스 연동 및 ORM 구현

### 목표
- .env 파일을 활용한 환경변수 관리
- python-dotenv 및 pydantic-settings 활용
- MySQL 데이터베이스 연동
- Tortoise ORM + asyncmy 드라이버 사용
- aerich를 활용한 데이터베이스 마이그레이션
- ORM 모델 설계 및 구현

### 최종 프로젝트 구조
```
fastapi_assignment/
├── app/
│   ├── configs/
│   │   ├── __init__.py
│   │   ├── base.py          # 설정 클래스
│   │   └── database.py      # DB 설정
│   ├── models/
│   │   ├── __init__.py
│   │   ├── base.py          # 기본 모델
│   │   ├── users.py         # 사용자 ORM 모델
│   │   └── movies.py        # 영화 ORM 모델
│   ├── schemas/
│   │   ├── users.py         # 사용자 스키마
│   │   └── movies.py        # 영화 스키마
│   ├── services/
│   │   ├── auth.py          # 인증 서비스
│   │   └── jwt.py           # JWT 서비스
│   ├── middleware/
│   │   └── auth.py          # 인증 미들웨어
│   ├── routers/
│   │   ├── users.py         # 사용자 라우터
│   │   └── movies.py        # 영화 라우터
│   └── tests/
│       ├── test_user_router.py
│       └── test_movie_router.py
├── .env                     # 환경변수
├── .github/workflows/ci.yml # CI/CD 파이프라인
├── main.py                  # FastAPI 앱
├── conftest.py              # 테스트 설정
└── pyproject.toml           # 프로젝트 설정
```

### 구현된 기능

**환경변수 관리**
```python
class Config(BaseSettings):
    SECRET_KEY: str = "default_secret_key"
    JWT_ALGORITHM: str = "HS256"
    JWT_ACCESS_TOKEN_EXPIRE_MINUTES: int = 30
    JWT_REFRESH_TOKEN_EXPIRE_MINUTES: int = 60 * 24 * 7
    
    MYSQL_HOST: str = "localhost"
    MYSQL_PORT: int = 3306
    MYSQL_USER: str = "root"
    MYSQL_PASSWORD: str = "1234"
    MYSQL_DB: str = "fastapi_assignment"
```

**Tortoise ORM 모델**
```python
class BaseModel(Model):
    id = fields.BigIntField(primary_key=True, autoincrement=True)
    created_at = fields.DatetimeField(auto_now_add=True)

class User(BaseModel):
    username = fields.CharField(max_length=50, unique=True, index=True)
    hashed_password = fields.CharField(max_length=128)
    age = fields.IntField()
    gender = fields.CharEnumField(GenderEnum)
    last_login = fields.DatetimeField(null=True)

class Movie(BaseModel):
    title = fields.CharField(max_length=255)
    plot = fields.TextField()
    cast = fields.JSONField()
    playtime = fields.IntField()
    genre = fields.CharEnumField(GenreEnum)
```

**데이터베이스 연동**
- 비동기 MySQL 연결 (asyncmy 드라이버)
- 연결 풀링 및 타임아웃 설정
- 한국 시간대 설정 (Asia/Seoul)
- 테스트용 SQLite 인메모리 DB 지원

**개선된 서비스 레이어**
- 환경변수 기반 JWT 설정
- Tortoise ORM 기반 비동기 데이터베이스 작업
- 비밀번호 해싱 및 검증 로직

**테스트 환경 구축**
- tortoise.contrib.test.TestCase 활용
- SQLite 인메모리 DB로 빠른 테스트 실행
- 각 테스트마다 독립적인 DB 상태 보장

**CI/CD 개선**
- SQLite 기반 테스트로 MySQL 의존성 제거
- 더 빠른 테스트 실행 시간
- 안정적인 CI 파이프라인

### 최종 성과
- **전체 테스트**: 25개 중 23개 통과 (92%)
- **영화 API**: 9개 테스트 모두 통과
- **코드 품질**: Black, Ruff, MyPy 모두 통과
- **데이터베이스**: MySQL 연동 완료
- **환경변수**: 보안 강화된 설정 관리

### 주요 특징
- **비동기 처리**: 모든 데이터베이스 작업 비동기화
- **ORM 활용**: Tortoise ORM으로 타입 안전한 DB 작업
- **환경변수 관리**: .env 파일과 pydantic-settings 연동
- **테스트 최적화**: 빠르고 안정적인 테스트 환경
- **모듈화**: 완전히 분리된 레이어 아키텍처

---

## 5일차: FormData 및 파일 업로드 시스템 구현

### 목표
- FastAPI의 FormData에 대한 이해 및 API 작성 시 활용
- Pydantic Model을 활용하여 FormData의 데이터 형식 지정 및 활용
- FastAPI의 File 객체에 대한 이해 및 API 작성 시 활용
- FastAPI의 UploadFile 객체에 대한 이해 및 활용
- AWS의 boto3 라이브러리를 활용하여 S3 객체 스토리지에 파일 업로드

### 확장된 프로젝트 구조
```
fastapi_assignment/
├── app/
│   ├── configs/
│   │   ├── __init__.py
│   │   ├── base.py          # 설정 클래스 (BASE_DIR, MEDIA_DIR 추가)
│   │   └── database.py      # DB 설정
│   ├── models/
│   │   ├── __init__.py
│   │   ├── base.py          # 기본 모델
│   │   ├── users.py         # 사용자 ORM 모델 (profile_image_url 추가)
│   │   └── movies.py        # 영화 ORM 모델 (poster_image_url 추가)
│   ├── schemas/
│   │   ├── users.py         # 사용자 스키마 (profile_image_url 추가)
│   │   └── movies.py        # 영화 스키마 (poster_image_url 추가)
│   ├── services/
│   │   ├── auth.py          # 인증 서비스
│   │   └── jwt.py           # JWT 서비스
│   ├── middleware/
│   │   └── auth.py          # 인증 미들웨어
│   ├── routers/
│   │   ├── users.py         # 사용자 라우터 (프로필 이미지 업로드 API 추가)
│   │   └── movies.py        # 영화 라우터 (포스터 이미지 업로드 API 추가)
│   ├── utils/
│   │   ├── __init__.py
│   │   └── file.py          # 파일 처리 유틸리티
│   └── tests/
│       ├── test_user_router.py
│       └── test_movie_router.py
├── .env                     # 환경변수
├── .github/workflows/ci.yml # CI/CD 파이프라인
├── main.py                  # FastAPI 앱
├── conftest.py              # 테스트 설정
├── pyproject.toml           # 프로젝트 설정
└── media/                   # 업로드된 파일 저장 디렉터리
    ├── users/
    │   └── profile_images/  # 사용자 프로필 이미지
    └── movies/
        └── poster_images/   # 영화 포스터 이미지
```

### 구현된 기능

**파일 처리 시스템**
```python
# app/utils/file.py
IMAGE_EXTENSIONS = ["jpg", "jpeg", "png", "gif"]

async def upload_file(file: UploadFile, upload_dir: str) -> str:
    """파일 업로드 및 UUID 기반 유니크 파일명 생성"""
    # 파일 확장자 분리
    # UUID가 추가된 유니크한 파일명 생성
    # 업로드 폴더 자동 생성
    # 파일 저장 및 URL 반환

def delete_file(file_url: str) -> None:
    """기존 파일 삭제"""

def validate_image_extension(file: UploadFile) -> str:
    """이미지 확장자 검증"""
```

**이미지 업로드 API**
- `POST /users/me/profile_image` - 사용자 프로필 이미지 업로드
- `POST /movies/{movie_id}/poster_image` - 영화 포스터 이미지 업로드

**데이터베이스 모델 확장**
```python
class User(BaseModel):
    username = fields.CharField(unique=True, max_length=50, index=True)
    hashed_password = fields.CharField(max_length=128)
    age = fields.IntField()
    gender = fields.CharEnumField(GenderEnum)
    profile_image_url = fields.CharField(max_length=255, null=True)  # 추가된 필드
    last_login = fields.DatetimeField(null=True)

class Movie(BaseModel):
    title = fields.CharField(max_length=255)
    plot = fields.TextField()
    cast = fields.JSONField()
    playtime = fields.IntField()
    genre = fields.CharEnumField(GenreEnum)
    poster_image_url = fields.CharField(max_length=255, null=True)  # 추가된 필드
```

**설정 관리 확장**
```python
class Config(BaseSettings):
    # 기존 설정들...
    
    BASE_DIR: Path = Path(__file__).resolve().parent.parent.parent
    MEDIA_DIR: str = os.path.join(BASE_DIR, "media")
```

**Pydantic 스키마 확장**
```python
class UserResponse(BaseModel):
    id: int
    username: str
    age: int
    gender: GenderEnum
    profile_image_url: str | None = None  # 추가된 필드

class MovieResponse(BaseModel):
    id: int
    title: str
    plot: str
    cast: list[CastModel]
    playtime: int
    genre: GenreEnum
    poster_image_url: str | None = None  # 추가된 필드
```

### 주요 특징

**파일 처리**
- UUID 기반 유니크 파일명 생성으로 충돌 방지
- 이미지 확장자 검증 (jpg, jpeg, png, gif)
- 자동 디렉터리 생성 및 관리
- 기존 파일 자동 삭제 기능

**보안 및 검증**
- 이미지 파일 형식 검증
- 파일 크기 및 확장자 제한
- 안전한 파일 저장 경로 관리

**사용자 경험**
- 기존 이미지 자동 교체
- 일관된 API 응답 형식
- 적절한 HTTP 상태 코드

### 최종 성과
- **전체 테스트**: 25개 모두 통과 (100%)
- **코드 품질**: Black, Ruff, MyPy 모두 통과
- **파일 업로드**: 사용자 프로필 및 영화 포스터 이미지 지원
- **보안**: 이미지 파일 검증 및 안전한 저장

---

## 6일차: 리뷰 시스템 및 좋아요 기능 구현

### 목표
- 리뷰 작성 및 관리 기능 구현
- 리뷰에 대한 좋아요/취소 기능 구현
- 사용자별 리뷰 및 영화별 리뷰 조회 기능
- FormData를 활용한 리뷰 이미지 업로드
- 데이터베이스 관계 설정 및 제약 조건 관리

### 추가된 구조
```
fastapi_assignment/
├── app/
│   ├── models/
│   │   ├── reviews.py            # 리뷰 모델
│   │   └── likes.py              # 리뷰 좋아요 모델
├── schemas/
│   ├── reviews.py            # 리뷰 Pydantic 스키마
│   └── likes.py              # 좋아요 Pydantic 스키마
├── routers/
│   ├── reviews.py            # 리뷰 관리 라우터
│   └── likes.py              # 좋아요 관리 라우터
└── media/
    └── reviews/
        └── images/           # 리뷰 이미지
```

### 구현된 기능

**리뷰 모델 (Review)**
```python
class Review(BaseModel, Model):
    user: fields.ForeignKeyRelation["User"] = fields.ForeignKeyField(
        "models.User", related_name="reviews", on_delete=fields.CASCADE
    )
    movie: fields.ForeignKeyRelation["Movie"] = fields.ForeignKeyField(
        "models.Movie", related_name="reviews", on_delete=fields.CASCADE
    )
    title = fields.CharField(max_length=50)
    content = fields.CharField(max_length=255)
    review_image_url = fields.CharField(max_length=255, null=True)

    class Meta:
        table = "reviews"
        unique_together = (("user", "movie"),)  # 사용자당 영화별 1개 리뷰만 작성 가능
```

**리뷰 좋아요 모델 (ReviewLike)**
```python
class ReviewLike(BaseModel, Model):
    user: fields.ForeignKeyRelation["User"] = fields.ForeignKeyField(
        "models.User", related_name="review_likes"
    )
    review: fields.ForeignKeyRelation["Review"] = fields.ForeignKeyField(
        "models.Review", related_name="likes"
    )
    is_liked = fields.BooleanField(default=True)

    class Meta:
        table = "review_likes"
        unique_together = (("user", "review"),)  # 사용자당 리뷰별 1개 좋아요만 가능
```

**Pydantic 스키마**
```python
# app/schemas/reviews.py
class ReviewResponse(BaseModel):
    id: int
    user_id: int
    movie_id: int
    title: str
    content: str
    review_image_url: str | None = None

# app/schemas/likes.py
class ReviewLikeResponse(BaseModel):
    id: int
    user_id: int
    review_id: int
    is_liked: bool

class ReviewLikeCountResponse(BaseModel):
    review_id: int
    like_count: int

class ReviewIsLikedResponse(BaseModel):
    review_id: int
    user_id: int
    is_liked: bool
```

**리뷰 관리 API**
```python
# app/routers/reviews.py
@review_router.post("", status_code=201)
async def create_movie_review(
    user: Annotated[User, Depends()],
    movie_id: int = Form(),
    title: str = Form(),
    content: str = Form(),
    review_image: UploadFile | None = File(None),
) -> ReviewResponse:
    """영화 리뷰 생성 API"""
    # FormData로 리뷰 정보 및 이미지 업로드 처리
    # unique_together 제약으로 중복 리뷰 방지

@review_router.get("/{review_id}")
async def get_review(review_id: int = Path(gt=0)) -> ReviewResponse:
    """리뷰 조회 API"""

@review_router.patch("/{review_id}")
async def update_review(
    user: Annotated[User, Depends()],
    review_id: int = Path(gt=0),
    update_title: str | None = Form(None),
    update_content: str | None = Form(None),
    update_image: UploadFile | None = File(None),
) -> ReviewResponse:
    """리뷰 수정 API (작성자만 가능)"""

@review_router.delete("/{review_id}", status_code=204)
async def delete_review(
    user: Annotated[User, Depends()],
    review_id: int = Path(gt=0)
) -> None:
    """리뷰 삭제 API (작성자만 가능)"""
```

**좋아요 관리 API**
```python
# app/routers/likes.py
@like_router.post("/reviews/{review_id}/like", status_code=200)
async def like_review(
    user: Annotated[User, Depends()],
    review_id: int = Path(gt=0)
) -> ReviewLikeResponse:
    """리뷰 좋아요 API"""

@like_router.post("/reviews/{review_id}/unlike", status_code=200)
async def unlike_review(
    user: Annotated[User, Depends()],
    review_id: int = Path(gt=0)
) -> ReviewLikeResponse:
    """리뷰 좋아요 취소 API"""
```

**추가 기능 API**
```python
# 리뷰 좋아요 개수 조회
@review_router.get("/{review_id}/like_count")
async def get_review_like_count(review_id: int = Path(gt=0)) -> dict[str, int]

# 사용자가 리뷰에 좋아요 눌렀는지 확인
@review_router.get("/{review_id}/is_liked")
async def get_user_review_is_liked(
    user: Annotated[User, Depends()],
    review_id: int = Path(gt=0)
) -> dict[str, int | bool]

# 사용자별 리뷰 조회
@user_router.get("/me/reviews")
async def get_my_reviews(request: Request) -> list[dict[str, int | str | None]]

# 영화별 리뷰 조회
@movie_router.get("/{movie_id}/reviews")
async def get_movie_reviews(movie_id: int = Path(gt=0)) -> list[dict[str, int | str | None]]
```

**주요 특징**

**데이터 무결성**
- `unique_together` 제약으로 중복 데이터 방지
- 사용자당 영화별 1개 리뷰만 작성 가능
- 사용자당 리뷰별 1개 좋아요만 가능

**권한 관리**
- 리뷰 작성자만 수정/삭제 가능 (403 Forbidden)
- 인증된 사용자만 좋아요 기능 사용 가능

**이미지 관리**
- FormData를 통한 리뷰 이미지 업로드
- 기존 이미지 자동 삭제 및 교체
- UUID 기반 유니크 파일명 생성

**관계 설정**
- User ↔ Review: 1:N 관계
- Movie ↔ Review: 1:N 관계
- User ↔ ReviewLike: 1:N 관계
- Review ↔ ReviewLike: 1:N 관계

**API 엔드포인트 요약**
- **리뷰 관리**: `POST`, `GET`, `PATCH`, `DELETE /reviews`
- **좋아요 관리**: `POST /likes/reviews/{review_id}/like`, `POST /likes/reviews/{review_id}/unlike`
- **추가 기능**: 좋아요 개수, 좋아요 상태, 사용자별 리뷰, 영화별 리뷰

### 최종 성과
- **전체 테스트**: 타입 검사 통과 (MyPy)
- **코드 품질**: Black, Ruff 포맷팅 완료
- **리뷰 시스템**: 완전한 CRUD 기능 구현
- **좋아요 시스템**: 좋아요/취소 및 상태 확인 기능
- **데이터 관계**: 복잡한 다대다 관계 설정 및 제약 조건 관리
- **이미지 업로드**: FormData를 활용한 리뷰 이미지 처리

---

## 7일차: 팔로우 시스템 및 영화 리액션 기능 구현

### 목표
- 사용자 간 팔로우/언팔로우 기능 구현
- 영화에 대한 좋아요/싫어요 리액션 기능 구현
- 복잡한 사용자 관계 및 영화 반응 데이터 관리
- 데이터베이스 제약 조건을 활용한 데이터 무결성 보장

### 추가된 구조
```
fastapi_assignment/
├── app/
│   ├── models/
│   │   ├── follows.py            # 팔로우 관계 모델
│   │   └── likes.py              # 기존 + 영화 리액션 모델
├── schemas/
│   ├── users.py                  # 기존 + 팔로우 관련 스키마
│   └── likes.py                  # 기존 + 영화 리액션 스키마
└── routers/
    ├── users.py                  # 기존 + 팔로우 관리 API
    ├── likes.py                  # 기존 + 영화 리액션 API
    └── movies.py                 # 기존 + 영화 리액션 개수 조회
```

### 구현된 기능

**팔로우 모델 (Follow)**
```python
class Follow(BaseModel, Model):
    follower: fields.ForeignKeyRelation["User"] = fields.ForeignKeyField(
        "models.User", related_name="followers"
    )
    following: fields.ForeignKeyRelation["User"] = fields.ForeignKeyField(
        "models.User", related_name="followings"
    )
    is_following = fields.BooleanField(default=True)

    class Meta:
        table = "follows"
        unique_together = (("follower", "following"),)  # 사용자당 1개 팔로우만 가능
```

**영화 리액션 모델 (MovieReaction)**
```python
class ReactionTypeEnum(StrEnum):
    LIKE = "like"
    DISLIKE = "dislike"

class MovieReaction(BaseModel, Model):
    user: fields.ForeignKeyRelation["User"] = fields.ForeignKeyField(
        "models.User", related_name="movie_reactions"
    )
    movie: fields.ForeignKeyRelation["Movie"] = fields.ForeignKeyField(
        "models.Movie", related_name="reactions"
    )
    type = fields.CharEnumField(ReactionTypeEnum, default=ReactionTypeEnum.LIKE)

    class Meta:
        table = "movie_reactions"
        unique_together = (("user", "movie"),)  # 사용자당 영화별 1개 리액션만 가능
```

**Pydantic 스키마**
```python
# app/schemas/users.py
class FollowResponse(BaseModel):
    follower_id: int
    following_id: int
    is_following: bool

class FollowingUserResponse(BaseModel):
    following_id: int
    username: str
    profile_image_url: str | None = None

class FollowerUserResponse(BaseModel):
    follower_id: int
    username: str
    profile_image_url: str | None = None

# app/schemas/likes.py
class MovieReactionResponse(BaseModel):
    id: int
    user_id: int
    movie_id: int
    type: ReactionTypeEnum

class MovieReactionCountResponse(BaseModel):
    movie_id: int
    like_count: int
    dislike_count: int
```

**팔로우 관리 API**
```python
# app/routers/users.py
@user_router.post("/{user_id}/follow", status_code=200)
async def following_user(
    user: Annotated[User, Depends()],
    user_id: int = Path(gt=0)
) -> FollowResponse:
    """사용자 팔로우 API"""
    # Follow 객체 생성 또는 is_following을 True로 업데이트

@user_router.post("/{user_id}/unfollow", status_code=200)
async def unfollowing_user(
    user: Annotated[User, Depends()],
    user_id: int = Path(gt=0)
) -> FollowResponse:
    """사용자 언팔로우 API"""
    # is_following을 False로 업데이트

@user_router.get("/me/followings", status_code=200)
async def get_my_followings(user: Annotated[User, Depends()]) -> list[FollowingUserResponse]:
    """내가 팔로우한 사용자 목록 조회 API"""

@user_router.get("/me/followers", status_code=200)
async def get_my_followers(user: Annotated[User, Depends()]) -> list[FollowerUserResponse]:
    """나를 팔로우하는 사용자 목록 조회 API"""
```

**영화 리액션 관리 API**
```python
# app/routers/likes.py
@like_router.post("/movies/{movie_id}/like", status_code=200)
async def like_movie(
    user: Annotated[User, Depends()],
    movie_id: int = Path(gt=0)
) -> MovieReactionResponse:
    """영화 좋아요 API"""
    # MovieReaction 생성 또는 type을 LIKE로 업데이트

@like_router.post("/movies/{movie_id}/dislike", status_code=200)
async def dislike_movie(
    user: Annotated[User, Depends()],
    movie_id: int = Path(gt=0)
) -> MovieReactionResponse:
    """영화 싫어요 API"""
    # MovieReaction 생성 또는 type을 DISLIKE로 업데이트

# app/routers/movies.py
@movie_router.get("/{movie_id}/reaction_count", status_code=200)
async def get_movie_reaction_count(movie_id: int = Path(gt=0)) -> dict[str, int]:
    """영화 리액션 개수 조회 API"""
    # 좋아요/싫어요 개수 반환
```

**주요 특징**

**팔로우 시스템**
- 사용자 간 양방향 팔로우 관계 관리
- `unique_together` 제약으로 중복 팔로우 방지
- `is_following` 상태로 팔로우/언팔로우 구분
- 팔로잉/팔로워 목록 조회 기능

**영화 리액션 시스템**
- `ReactionTypeEnum`으로 LIKE/DISLIKE 구분
- 사용자당 영화별 1개 리액션만 가능
- 좋아요 ↔ 싫어요 전환 기능
- 실시간 리액션 개수 집계

**데이터 관계 설계**
- User ↔ Follow: 1:N 관계 (팔로워/팔로잉)
- User ↔ MovieReaction: 1:N 관계 (사용자별 영화 리액션)
- Movie ↔ MovieReaction: 1:N 관계 (영화별 사용자 리액션)

**API 엔드포인트 요약**
- **팔로우 관리**: `POST /users/{user_id}/follow`, `POST /users/{user_id}/unfollow`
- **팔로우 조회**: `GET /users/me/followings`, `GET /users/me/followers`
- **영화 리액션**: `POST /likes/movies/{movie_id}/like`, `POST /likes/movies/{movie_id}/dislike`
- **리액션 통계**: `GET /movies/{movie_id}/reaction_count`

### 최종 성과
- **코드 품질**: Black, Ruff, MyPy 모두 통과 (100%)
- **팔로우 시스템**: 완전한 팔로우/언팔로우 기능 구현
- **영화 리액션**: 좋아요/싫어요 시스템 구현
- **데이터 무결성**: unique_together 제약으로 중복 데이터 방지
- **사용자 경험**: 직관적인 팔로우 관계 및 영화 반응 관리
- **아키텍처**: 깔끔한 모델 분리 및 관계 설정

---

## 8일차: WebSocket 실시간 알림 시스템 구현

### 목표
- FastAPI의 WebSocket을 사용하여 웹소켓 연결을 구성할 수 있다
- 데이터베이스에 객체를 생성, 수정, 삭제 시 Tortoise-ORM의 signals를 활용하여 특정 동작을 추가로 구현할 수 있다
- 위의 두 개념을 바탕으로 웹소켓을 이용한 실시간 알림을 구현할 수 있다

### 추가된 구조
```
fastapi_assignment/
├── app/
│   ├── utils/
│   │   └── websocket.py              # WebSocket 연결 관리자
│   ├── routers/
│   │   └── notifications.py          # WebSocket 알림 라우터
│   ├── signals/
│   │   ├── __init__.py               # 시그널 초기화
│   │   ├── follow_signals.py         # 팔로우 시그널
│   │   └── review_like_signals.py    # 리뷰 좋아요 시그널
│   └── main.py                       # 시그널 등록 및 라우터 추가
```

### 구현된 기능

**WebSocket 연결 관리자 (WebSocketConnectionManager)**
```python
class WebSocketConnectionManager:
    def __init__(self) -> None:
        # 활성화된 소켓 연결을 담을 딕셔너리. {user_id: WebSocket} 의 형태
        self.active_connections: dict[int, WebSocket] = {}

    async def connect(self, user_id: int, ws: WebSocket) -> None:
        """웹 소켓 연결 수락 후 user_id를 키값으로 소켓 연결 추가"""
        await ws.accept()
        self.active_connections[user_id] = ws

    async def disconnect(self, ws: WebSocket) -> None:
        """WebSocket 객체를 active_connections에서 제거"""
        for user_id, conn in list(self.active_connections.items()):
            if conn == ws:
                del self.active_connections[user_id]
                break

    def get_user_connection(self, user_id: int) -> WebSocket | None:
        """user_id를 통해 현재 유저의 웹소켓 커넥션 가져오기"""
        if user_id not in self.active_connections:
            return None
        return self.active_connections[user_id]

    async def send_notification(self, user_id: int, message: str) -> None:
        """특정 사용자에게 WebSocket을 통해 알림 메시지 전송"""
        ws = self.get_user_connection(user_id=user_id)
        if ws:
            await ws.send_json(data={"message": message})
```

**WebSocket 알림 라우터**
```python
@notification_router.websocket("")
async def websocket_notifications(websocket: WebSocket) -> None:
    """실시간 알림을 위한 WebSocket 연결 엔드포인트"""
    # JWT 토큰을 Authorization 헤더에서 가져옴
    token = websocket.headers.get("Authorization")
    
    if not token:
        await websocket.close(code=4001, reason="Authorization header required")
        return

    # 토큰 검증 및 사용자 인증
    try:
        from app.services.auth import AuthService
        from app.services.jwt import JWTService
        
        jwt_service = JWTService()
        payload = jwt_service.decode_token(token.split(" ")[1])
        username = payload.get("username")
        
        if not username:
            await websocket.close(code=4001, reason="Invalid token")
            return
            
        auth_service = AuthService()
        user = await auth_service.get_current_user(username)
        
        if not user:
            await websocket.close(code=4001, reason="User not found")
            return
            
    except Exception:
        await websocket.close(code=4001, reason="Invalid token")
        return

    # WebSocket 연결 수락 및 관리
    await manager.connect(user_id=user.id, ws=websocket)

    try:
        while websocket.client_state != WebSocketState.DISCONNECTED:
            await websocket.receive()
    except WebSocketDisconnect:
        await manager.disconnect(ws=websocket)
```

**Tortoise ORM Signals**

**팔로우 시그널 (`app/signals/follow_signals.py`)**
```python
@post_save(Follow)
async def follow_signals(
    sender: Any, 
    instance: Follow, 
    created: bool, 
    using_db: Any, 
    update_fields: Any, 
    **kwargs: Any
) -> None:
    """Follow 객체가 저장될 때 팔로잉 유저에게 실시간 알림 전송"""
    if created or instance.is_following:
        await instance.fetch_related("follower", "following")
        
        await manager.send_notification(
            user_id=instance.following.id,
            message=f"{instance.follower.username}님이 팔로우 하셨습니다."
        )
```

**리뷰 좋아요 시그널 (`app/signals/review_like_signals.py`)**
```python
@post_save(ReviewLike)
async def review_like_signals(
    sender: Any, 
    instance: ReviewLike, 
    created: bool, 
    using_db: Any, 
    update_fields: Any, 
    **kwargs: Any
) -> None:
    """ReviewLike 객체가 저장될 때 리뷰 작성자에게 실시간 알림 전송"""
    if created or instance.is_liked:
        await instance.fetch_related("review__user", "user")
        review_writer = instance.review.user
        user = instance.user

        await manager.send_notification(
            user_id=review_writer.id,
            message=f"{user.username}님이 내 리뷰에 좋아요를 눌렀습니다!"
        )
```

**시그널 등록 및 초기화**
```python
# app/signals/__init__.py
import app.signals.follow_signals
import app.signals.review_like_signals

__all__ = ["app", "follow_signals", "review_like_signals"]

# main.py
# 시그널 임포트
import app.signals
```

### 주요 특징

**WebSocket 연결 관리**
- 사용자별 독립적인 WebSocket 연결 관리
- 연결 상태 추적 및 자동 정리
- 실시간 양방향 통신 지원

**실시간 알림 시스템**
- 팔로우 시 자동 알림: `"{username}님이 팔로우 하셨습니다."`
- 리뷰 좋아요 시 자동 알림: `"{username}님이 내 리뷰에 좋아요를 눌렀습니다!"`
- JSON 형태의 구조화된 메시지 전송

**Tortoise ORM Signals 활용**
- `@post_save` 데코레이터로 데이터베이스 변경 감지
- 자동 트리거로 알림 시스템 구동
- 비동기 처리로 성능 최적화

**보안 및 인증**
- JWT 토큰 기반 사용자 인증
- WebSocket 연결 시 토큰 검증
- 잘못된 인증 시 연결 거부

### 실시간 알림 동작 흐름

1. **사용자 연결**: WebSocket을 통해 사용자가 서버에 연결
2. **이벤트 발생**: 팔로우 또는 리뷰 좋아요 액션 발생
3. **Signal 트리거**: Tortoise ORM의 post_save 시그널 자동 실행
4. **알림 전송**: WebSocket을 통해 해당 사용자에게 실시간 알림 전송

### API 엔드포인트

**WebSocket 연결**
- **URL**: `ws://localhost:8000/notifications`
- **인증**: Authorization 헤더에 JWT 토큰 필요
- **프로토콜**: WebSocket (ws://)

**알림 메시지 형식**
```json
{
    "message": "사용자명님이 팔로우 하셨습니다."
}
```

### 테스트 방법

**Postman WebSocket 테스트**
1. Postman에서 New → WebSocket Request 생성
2. URL: `ws://localhost:8000/notifications`
3. Headers: `Authorization: Bearer {JWT_TOKEN}`
4. Connect 클릭하여 연결
5. Swagger API로 팔로우/좋아요 액션 실행
6. WebSocket에서 실시간 알림 메시지 확인

### 최종 성과
- **코드 품질**: Black, Ruff, MyPy 모두 통과 (100%)
- **WebSocket 시스템**: 실시간 양방향 통신 구현
- **Signals 시스템**: 데이터베이스 이벤트 자동 감지 및 처리
- **실시간 알림**: 팔로우 및 리뷰 좋아요 시 자동 알림 전송
- **보안**: JWT 토큰 기반 WebSocket 인증
- **아키텍처**: 이벤트 기반 실시간 알림 시스템 구축