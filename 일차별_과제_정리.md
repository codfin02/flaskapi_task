# FastAPI 과제 일차별 정리

## 1일차: FastAPI 기본 구조 및 API 작성

### 목표
- Poetry를 사용한 가상환경 구축 및 의존성 관리
- FastAPI 프로젝트 구성 및 서버 실행
- Pydantic 모델을 활용한 데이터 검증
- 경로 매개변수와 쿼리 매개변수 활용
- 코드 품질 관리 도구 설정 (ruff, black, mypy)
- pytest를 활용한 TDD 개발

### 프로젝트 구조
```
fastapi_assignment/
├── app/
│   ├── models/
│   │   ├── __init__.py
│   │   └── users.py          # 사용자 모델
│   ├── schemas/
│   │   ├── __init__.py
│   │   └── users.py          # Pydantic 스키마
│   ├── tests/
│   │   ├── __init__.py
│   │   └── test_user_router.py
│   └── __init__.py
├── main.py                   # FastAPI 애플리케이션
├── pyproject.toml           # Poetry 설정
├── conftest.py              # pytest 설정
├── test.sh                  # 통합 테스트 스크립트
└── README.md
```

### 구현된 기능

**사용자 관리 API**
- `POST /users` - 사용자 생성
- `GET /users` - 모든 사용자 조회
- `GET /users/{user_id}` - 특정 사용자 조회 (Path Parameter 검증)
- `PATCH /users/{user_id}` - 사용자 정보 부분 수정
- `DELETE /users/{user_id}` - 사용자 삭제
- `GET /users/search` - 사용자 검색 (Query Parameter 검증)

**Pydantic 스키마**
```python
class GenderEnum(str, Enum):
    MALE = "male"
    FEMALE = "female"

class UserCreateRequest(BaseModel):
    username: str
    age: int
    gender: GenderEnum

class UserUpdateRequest(BaseModel):
    username: Optional[str] = None
    age: Optional[int] = None

class UserSearchParams(BaseModel):
    model_config = {"extra": "forbid"}
    username: Optional[str] = None
    age: Optional[conint(gt=0)] = None
    gender: Optional[GenderEnum] = None
```

**코드 품질 도구**
- Black: 코드 포맷팅
- Ruff: 린팅 및 import 정리
- MyPy: 정적 타입 검사
- Coverage: 테스트 커버리지 측정

**테스트 결과**
- 전체 테스트: 16개 모두 통과
- 테스트 커버리지: 99% 달성

---

## 2일차: 영화 관리 API 구현

### 목표
- 다중 매개변수를 활용한 API 구성
- Pydantic Field를 이용한 모델 내 데이터 검증
- 중첩 모델 및 서브 모델 활용
- HTTP 상태 코드 적절한 활용
- 응답 모델(Response Model) 활용

### 추가된 구조
```
app/
├── models/
│   └── movies.py            # 영화 모델
└── schemas/
    └── movies.py            # 영화 Pydantic 스키마
```

### 구현된 기능

**영화 관리 API**
- `POST /movies` - 영화 등록 (201 Created)
- `GET /movies` - 전체 영화 조회 및 검색 (200 OK)
- `GET /movies/{movie_id}` - 특정 영화 상세 조회 (200 OK)
- `PATCH /movies/{movie_id}` - 영화 정보 수정 (200 OK)
- `DELETE /movies/{movie_id}` - 영화 삭제 (204 No Content)

**영화 스키마**
```python
class CreateMovieRequest(BaseModel):
    title: str
    playtime: int
    genre: list[str]

class MovieUpdateRequest(BaseModel):
    title: Optional[str] = None
    playtime: Optional[Annotated[int, Field(gt=0)]] = None
    genre: Optional[list[str]] = None

class MovieSearchParams(BaseModel):
    title: Optional[str] = None
    genre: Optional[str] = None
```

**주요 특징**
- Field(gt=0)를 사용한 playtime 검증
- 상태 코드별 적절한 응답 처리
- 장르 기반 검색 기능 구현
- Response Model을 활용한 일관된 응답 형식

**테스트 결과**
- 사용자 테스트: 16개 통과
- 영화 테스트: 9개 통과
- 전체 테스트: 25개 모두 통과

---

## 3일차: 고급 FastAPI 기능 구현

### 목표
- Shell Script 작성 및 활용
- GitHub Actions CI/CD 파이프라인 구축
- FastAPI 내부 모듈 및 함수 활용
- API 라우터 모듈화

### 확장된 구조
```
fastapi_assignment/
├── app/
│   ├── middleware/
│   │   ├── __init__.py
│   │   └── auth.py          # 인증 미들웨어
│   ├── routers/
│   │   ├── __init__.py
│   │   ├── users.py         # 사용자 라우터
│   │   └── movies.py        # 영화 라우터
│   └── services/
│       ├── __init__.py
│       ├── auth.py          # 인증 서비스
│       └── jwt.py           # JWT 서비스
├── .github/workflows/
│   └── ci.yml               # GitHub Actions 설정
└── test.sh                  # 개선된 테스트 스크립트
```

### 구현된 기능

**모듈화된 라우터**
- APIRouter를 사용한 엔드포인트 분리
- 태그별 API 그룹화
- 메인 앱에서 include_router()로 통합

**인증 시스템**
- JWT 기반 액세스/리프레시 토큰
- 비밀번호 bcrypt 해싱
- 쿠키 기반 토큰 전송
- 인증 미들웨어 자동 처리

**새로운 API 엔드포인트**
- `POST /users/login` - 사용자 로그인
- `GET /users/me` - 현재 사용자 정보 조회
- `PATCH /users/me` - 현재 사용자 정보 수정
- `DELETE /users/me` - 현재 사용자 삭제

**Shell Script 개선**
```bash
# 옵션 지원
./test.sh --skip-format    # 포맷팅 건너뛰기
./test.sh --skip-lint      # 린팅 건너뛰기
./test.sh --skip-type      # 타입 검사 건너뛰기
./test.sh --skip-test      # 테스트 건너뛰기
```

**GitHub Actions CI/CD**
- 정적 분석과 테스트 병렬 실행
- Poetry 캐싱으로 빌드 시간 단축
- MySQL 데이터베이스 자동 설정

---

## 4일차: 데이터베이스 연동 및 ORM 구현

### 목표
- .env 파일을 활용한 환경변수 관리
- python-dotenv 및 pydantic-settings 활용
- MySQL 데이터베이스 연동
- Tortoise ORM + asyncmy 드라이버 사용
- aerich를 활용한 데이터베이스 마이그레이션
- ORM 모델 설계 및 구현

### 최종 프로젝트 구조
```
fastapi_assignment/
├── app/
│   ├── configs/
│   │   ├── __init__.py
│   │   ├── base.py          # 설정 클래스
│   │   └── database.py      # DB 설정
│   ├── models/
│   │   ├── __init__.py
│   │   ├── base.py          # 기본 모델
│   │   ├── users.py         # 사용자 ORM 모델
│   │   └── movies.py        # 영화 ORM 모델
│   ├── schemas/
│   │   ├── users.py         # 사용자 스키마
│   │   └── movies.py        # 영화 스키마
│   ├── services/
│   │   ├── auth.py          # 인증 서비스
│   │   └── jwt.py           # JWT 서비스
│   ├── middleware/
│   │   └── auth.py          # 인증 미들웨어
│   ├── routers/
│   │   ├── users.py         # 사용자 라우터
│   │   └── movies.py        # 영화 라우터
│   └── tests/
│       ├── test_user_router.py
│       └── test_movie_router.py
├── .env                     # 환경변수
├── .github/workflows/ci.yml # CI/CD 파이프라인
├── main.py                  # FastAPI 앱
├── conftest.py              # 테스트 설정
└── pyproject.toml           # 프로젝트 설정
```

### 구현된 기능

**환경변수 관리**
```python
class Config(BaseSettings):
    SECRET_KEY: str = "default_secret_key"
    JWT_ALGORITHM: str = "HS256"
    JWT_ACCESS_TOKEN_EXPIRE_MINUTES: int = 30
    JWT_REFRESH_TOKEN_EXPIRE_MINUTES: int = 60 * 24 * 7
    
    MYSQL_HOST: str = "localhost"
    MYSQL_PORT: int = 3306
    MYSQL_USER: str = "root"
    MYSQL_PASSWORD: str = "1234"
    MYSQL_DB: str = "fastapi_assignment"
```

**Tortoise ORM 모델**
```python
class BaseModel(Model):
    id = fields.BigIntField(primary_key=True, autoincrement=True)
    created_at = fields.DatetimeField(auto_now_add=True)

class User(BaseModel):
    username = fields.CharField(max_length=50, unique=True, index=True)
    hashed_password = fields.CharField(max_length=128)
    age = fields.IntField()
    gender = fields.CharEnumField(GenderEnum)
    last_login = fields.DatetimeField(null=True)

class Movie(BaseModel):
    title = fields.CharField(max_length=255)
    plot = fields.TextField()
    cast = fields.JSONField()
    playtime = fields.IntField()
    genre = fields.CharEnumField(GenreEnum)
```

**데이터베이스 연동**
- 비동기 MySQL 연결 (asyncmy 드라이버)
- 연결 풀링 및 타임아웃 설정
- 한국 시간대 설정 (Asia/Seoul)
- 테스트용 SQLite 인메모리 DB 지원

**개선된 서비스 레이어**
- 환경변수 기반 JWT 설정
- Tortoise ORM 기반 비동기 데이터베이스 작업
- 비밀번호 해싱 및 검증 로직

**테스트 환경 구축**
- tortoise.contrib.test.TestCase 활용
- SQLite 인메모리 DB로 빠른 테스트 실행
- 각 테스트마다 독립적인 DB 상태 보장

**CI/CD 개선**
- SQLite 기반 테스트로 MySQL 의존성 제거
- 더 빠른 테스트 실행 시간
- 안정적인 CI 파이프라인

### 최종 성과
- **전체 테스트**: 25개 중 23개 통과 (92%)
- **영화 API**: 9개 테스트 모두 통과
- **코드 품질**: Black, Ruff, MyPy 모두 통과
- **데이터베이스**: MySQL 연동 완료
- **환경변수**: 보안 강화된 설정 관리

### 주요 특징
- **비동기 처리**: 모든 데이터베이스 작업 비동기화
- **ORM 활용**: Tortoise ORM으로 타입 안전한 DB 작업
- **환경변수 관리**: .env 파일과 pydantic-settings 연동
- **테스트 최적화**: 빠르고 안정적인 테스트 환경
- **모듈화**: 완전히 분리된 레이어 아키텍처

---

## 5일차: FormData 및 파일 업로드 시스템 구현

### 목표
- FastAPI의 FormData에 대한 이해 및 API 작성 시 활용
- Pydantic Model을 활용하여 FormData의 데이터 형식 지정 및 활용
- FastAPI의 File 객체에 대한 이해 및 API 작성 시 활용
- FastAPI의 UploadFile 객체에 대한 이해 및 활용
- AWS의 boto3 라이브러리를 활용하여 S3 객체 스토리지에 파일 업로드

### 확장된 프로젝트 구조
```
fastapi_assignment/
├── app/
│   ├── configs/
│   │   ├── __init__.py
│   │   ├── base.py          # 설정 클래스 (BASE_DIR, MEDIA_DIR 추가)
│   │   └── database.py      # DB 설정
│   ├── models/
│   │   ├── __init__.py
│   │   ├── base.py          # 기본 모델
│   │   ├── users.py         # 사용자 ORM 모델 (profile_image_url 추가)
│   │   └── movies.py        # 영화 ORM 모델 (poster_image_url 추가)
│   ├── schemas/
│   │   ├── users.py         # 사용자 스키마 (profile_image_url 추가)
│   │   └── movies.py        # 영화 스키마 (poster_image_url 추가)
│   ├── services/
│   │   ├── auth.py          # 인증 서비스
│   │   └── jwt.py           # JWT 서비스
│   ├── middleware/
│   │   └── auth.py          # 인증 미들웨어
│   ├── routers/
│   │   ├── users.py         # 사용자 라우터 (프로필 이미지 업로드 API 추가)
│   │   └── movies.py        # 영화 라우터 (포스터 이미지 업로드 API 추가)
│   ├── utils/
│   │   ├── __init__.py
│   │   └── file.py          # 파일 처리 유틸리티
│   └── tests/
│       ├── test_user_router.py
│       └── test_movie_router.py
├── .env                     # 환경변수
├── .github/workflows/ci.yml # CI/CD 파이프라인
├── main.py                  # FastAPI 앱
├── conftest.py              # 테스트 설정
├── pyproject.toml           # 프로젝트 설정
└── media/                   # 업로드된 파일 저장 디렉터리
    ├── users/
    │   └── profile_images/  # 사용자 프로필 이미지
    └── movies/
        └── poster_images/   # 영화 포스터 이미지
```

### 구현된 기능

**파일 처리 시스템**
```python
# app/utils/file.py
IMAGE_EXTENSIONS = ["jpg", "jpeg", "png", "gif"]

async def upload_file(file: UploadFile, upload_dir: str) -> str:
    """파일 업로드 및 UUID 기반 유니크 파일명 생성"""
    # 파일 확장자 분리
    # UUID가 추가된 유니크한 파일명 생성
    # 업로드 폴더 자동 생성
    # 파일 저장 및 URL 반환

def delete_file(file_url: str) -> None:
    """기존 파일 삭제"""

def validate_image_extension(file: UploadFile) -> str:
    """이미지 확장자 검증"""
```

**이미지 업로드 API**
- `POST /users/me/profile_image` - 사용자 프로필 이미지 업로드
- `POST /movies/{movie_id}/poster_image` - 영화 포스터 이미지 업로드

**데이터베이스 모델 확장**
```python
class User(BaseModel):
    username = fields.CharField(unique=True, max_length=50, index=True)
    hashed_password = fields.CharField(max_length=128)
    age = fields.IntField()
    gender = fields.CharEnumField(GenderEnum)
    profile_image_url = fields.CharField(max_length=255, null=True)  # 추가된 필드
    last_login = fields.DatetimeField(null=True)

class Movie(BaseModel):
    title = fields.CharField(max_length=255)
    plot = fields.TextField()
    cast = fields.JSONField()
    playtime = fields.IntField()
    genre = fields.CharEnumField(GenreEnum)
    poster_image_url = fields.CharField(max_length=255, null=True)  # 추가된 필드
```

**설정 관리 확장**
```python
class Config(BaseSettings):
    # 기존 설정들...
    
    BASE_DIR: Path = Path(__file__).resolve().parent.parent.parent
    MEDIA_DIR: str = os.path.join(BASE_DIR, "media")
```

**Pydantic 스키마 확장**
```python
class UserResponse(BaseModel):
    id: int
    username: str
    age: int
    gender: GenderEnum
    profile_image_url: str | None = None  # 추가된 필드

class MovieResponse(BaseModel):
    id: int
    title: str
    plot: str
    cast: list[CastModel]
    playtime: int
    genre: GenreEnum
    poster_image_url: str | None = None  # 추가된 필드
```

### 주요 특징

**파일 처리**
- UUID 기반 유니크 파일명 생성으로 충돌 방지
- 이미지 확장자 검증 (jpg, jpeg, png, gif)
- 자동 디렉터리 생성 및 관리
- 기존 파일 자동 삭제 기능

**보안 및 검증**
- 이미지 파일 형식 검증
- 파일 크기 및 확장자 제한
- 안전한 파일 저장 경로 관리

**사용자 경험**
- 기존 이미지 자동 교체
- 일관된 API 응답 형식
- 적절한 HTTP 상태 코드

### 최종 성과
- **전체 테스트**: 25개 모두 통과 (100%)
- **코드 품질**: Black, Ruff, MyPy 모두 통과
- **파일 업로드**: 사용자 프로필 및 영화 포스터 이미지 지원
- **보안**: 이미지 파일 검증 및 안전한 저장

---

## 6일차: 리뷰 시스템 및 좋아요 기능 구현

### 목표
- 리뷰 작성 및 관리 기능 구현
- 리뷰에 대한 좋아요/취소 기능 구현
- 사용자별 리뷰 및 영화별 리뷰 조회 기능
- FormData를 활용한 리뷰 이미지 업로드
- 데이터베이스 관계 설정 및 제약 조건 관리

### 추가된 구조
```
fastapi_assignment/
├── app/
│   ├── models/
│   │   ├── reviews.py            # 리뷰 모델
│   │   └── likes.py              # 리뷰 좋아요 모델
├── schemas/
│   ├── reviews.py            # 리뷰 Pydantic 스키마
│   └── likes.py              # 좋아요 Pydantic 스키마
├── routers/
│   ├── reviews.py            # 리뷰 관리 라우터
│   └── likes.py              # 좋아요 관리 라우터
└── media/
    └── reviews/
        └── images/           # 리뷰 이미지
```

### 구현된 기능

**리뷰 모델 (Review)**
```python
class Review(BaseModel, Model):
    user: fields.ForeignKeyRelation["User"] = fields.ForeignKeyField(
        "models.User", related_name="reviews", on_delete=fields.CASCADE
    )
    movie: fields.ForeignKeyRelation["Movie"] = fields.ForeignKeyField(
        "models.Movie", related_name="reviews", on_delete=fields.CASCADE
    )
    title = fields.CharField(max_length=50)
    content = fields.CharField(max_length=255)
    review_image_url = fields.CharField(max_length=255, null=True)

    class Meta:
        table = "reviews"
        unique_together = (("user", "movie"),)  # 사용자당 영화별 1개 리뷰만 작성 가능
```

**리뷰 좋아요 모델 (ReviewLike)**
```python
class ReviewLike(BaseModel, Model):
    user: fields.ForeignKeyRelation["User"] = fields.ForeignKeyField(
        "models.User", related_name="review_likes"
    )
    review: fields.ForeignKeyRelation["Review"] = fields.ForeignKeyField(
        "models.Review", related_name="likes"
    )
    is_liked = fields.BooleanField(default=True)

    class Meta:
        table = "review_likes"
        unique_together = (("user", "review"),)  # 사용자당 리뷰별 1개 좋아요만 가능
```

**Pydantic 스키마**
```python
# app/schemas/reviews.py
class ReviewResponse(BaseModel):
    id: int
    user_id: int
    movie_id: int
    title: str
    content: str
    review_image_url: str | None = None

# app/schemas/likes.py
class ReviewLikeResponse(BaseModel):
    id: int
    user_id: int
    review_id: int
    is_liked: bool

class ReviewLikeCountResponse(BaseModel):
    review_id: int
    like_count: int

class ReviewIsLikedResponse(BaseModel):
    review_id: int
    user_id: int
    is_liked: bool
```

**리뷰 관리 API**
```python
# app/routers/reviews.py
@review_router.post("", status_code=201)
async def create_movie_review(
    user: Annotated[User, Depends()],
    movie_id: int = Form(),
    title: str = Form(),
    content: str = Form(),
    review_image: UploadFile | None = File(None),
) -> ReviewResponse:
    """영화 리뷰 생성 API"""
    # FormData로 리뷰 정보 및 이미지 업로드 처리
    # unique_together 제약으로 중복 리뷰 방지

@review_router.get("/{review_id}")
async def get_review(review_id: int = Path(gt=0)) -> ReviewResponse:
    """리뷰 조회 API"""

@review_router.patch("/{review_id}")
async def update_review(
    user: Annotated[User, Depends()],
    review_id: int = Path(gt=0),
    update_title: str | None = Form(None),
    update_content: str | None = Form(None),
    update_image: UploadFile | None = File(None),
) -> ReviewResponse:
    """리뷰 수정 API (작성자만 가능)"""

@review_router.delete("/{review_id}", status_code=204)
async def delete_review(
    user: Annotated[User, Depends()],
    review_id: int = Path(gt=0)
) -> None:
    """리뷰 삭제 API (작성자만 가능)"""
```

**좋아요 관리 API**
```python
# app/routers/likes.py
@like_router.post("/reviews/{review_id}/like", status_code=200)
async def like_review(
    user: Annotated[User, Depends()],
    review_id: int = Path(gt=0)
) -> ReviewLikeResponse:
    """리뷰 좋아요 API"""

@like_router.post("/reviews/{review_id}/unlike", status_code=200)
async def unlike_review(
    user: Annotated[User, Depends()],
    review_id: int = Path(gt=0)
) -> ReviewLikeResponse:
    """리뷰 좋아요 취소 API"""
```

**추가 기능 API**
```python
# 리뷰 좋아요 개수 조회
@review_router.get("/{review_id}/like_count")
async def get_review_like_count(review_id: int = Path(gt=0)) -> dict[str, int]

# 사용자가 리뷰에 좋아요 눌렀는지 확인
@review_router.get("/{review_id}/is_liked")
async def get_user_review_is_liked(
    user: Annotated[User, Depends()],
    review_id: int = Path(gt=0)
) -> dict[str, int | bool]

# 사용자별 리뷰 조회
@user_router.get("/me/reviews")
async def get_my_reviews(request: Request) -> list[dict[str, int | str | None]]

# 영화별 리뷰 조회
@movie_router.get("/{movie_id}/reviews")
async def get_movie_reviews(movie_id: int = Path(gt=0)) -> list[dict[str, int | str | None]]
```

**주요 특징**

**데이터 무결성**
- `unique_together` 제약으로 중복 데이터 방지
- 사용자당 영화별 1개 리뷰만 작성 가능
- 사용자당 리뷰별 1개 좋아요만 가능

**권한 관리**
- 리뷰 작성자만 수정/삭제 가능 (403 Forbidden)
- 인증된 사용자만 좋아요 기능 사용 가능

**이미지 관리**
- FormData를 통한 리뷰 이미지 업로드
- 기존 이미지 자동 삭제 및 교체
- UUID 기반 유니크 파일명 생성

**관계 설정**
- User ↔ Review: 1:N 관계
- Movie ↔ Review: 1:N 관계
- User ↔ ReviewLike: 1:N 관계
- Review ↔ ReviewLike: 1:N 관계

**API 엔드포인트 요약**
- **리뷰 관리**: `POST`, `GET`, `PATCH`, `DELETE /reviews`
- **좋아요 관리**: `POST /likes/reviews/{review_id}/like`, `POST /likes/reviews/{review_id}/unlike`
- **추가 기능**: 좋아요 개수, 좋아요 상태, 사용자별 리뷰, 영화별 리뷰

### 최종 성과
- **전체 테스트**: 타입 검사 통과 (MyPy)
- **코드 품질**: Black, Ruff 포맷팅 완료
- **리뷰 시스템**: 완전한 CRUD 기능 구현
- **좋아요 시스템**: 좋아요/취소 및 상태 확인 기능
- **데이터 관계**: 복잡한 다대다 관계 설정 및 제약 조건 관리
- **이미지 업로드**: FormData를 활용한 리뷰 이미지 처리